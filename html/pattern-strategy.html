<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>策略模式？</title>
        <link rel="stylesheet" href="../assets/style.css">
    </head>
    
    <body>
        <div class="app">
        <header class="navbar"><p><a class="logo" href="/">fe-cookbook</a></p>
<div class="menus">
<a class="item" href="/">首页</a>
</div>
</header>
        <aside class="sidebar">
    <ul class="ul-0"><li class="li-1"><p class="a-2">前端面试</p></li><li class="li-1"><p class="a-2">html/css</p><ul class="ul-2"><li class="li-3"><a href="html-html5.html" class="a-4">html5</a></li></ul></li><li class="li-1"><p class="a-2">javascrpt</p><ul class="ul-2"><li class="li-3"><a href="javascript-render.html" class="a-4">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li><li class="li-3"><a href="javascript-clone.html" class="a-4">深拷贝和浅拷贝？</a></li><li class="li-3"><a href="javascript-isnan.html" class="a-4">怎么判断一个变量是不是 NaN?</a></li><li class="li-3"><a href="javascript-reduce.html" class="a-4">array reduce 返回值是什么？</a></li><li class="li-3"><a href="javascript-vueprototype.html" class="a-4">vue 组件挂载到全局方法？</a></li><li class="li-3"><a href="javascript-constructor.html" class="a-4">构造函数的返回值是什么？</a></li><li class="li-3"><a href="javascript-vueinsertcomponent.html" class="a-4">怎么通过编程的方式而不是<'my-component'>的方式动态的插入 Vue components?</a></li><li class="li-3"><a href="javascript-object_get.html" class="a-4">获取对象路径处的值\_.get(object, a.b.c, default)</a></li><li class="li-3"><a href="javascript-null.html" class="a-4">[typeof null, null instanceof Object]表达式的返回值是什么？</a></li><li class="li-3"><a href="javascript-array_map_parseint.html" class="a-4">["1", "2", "3"].map(parseInt) 返回值是什么？</a></li><li class="li-3"><a href="javascript-debounce.html" class="a-4">什么是防抖和节流？有什么区别？如何实现？</a></li><li class="li-3"><a href="javascript-object_defineproperty.html" class="a-4">Object.defineProperty 了解有多少？什么是属性描述符？</a></li><li class="li-3"><a href="javascript-mutationobserver.html" class="a-4">怎么监视对 DOM 树的变化</a></li><li class="li-3"><a href="javascript-vueerror.html" class="a-4">Vue 是怎么进行错误处理的？</a></li><li class="li-3"><a href="javascript-esmodules.html" class="a-4">ES6 Modules？</a></li><li class="li-3"><a href="javascript-bind.html" class="a-4">实现一个 bind 函数？</a></li></ul></li></ul><ul class="ul-0"><li class="li-1"><p class="a-2">基础知识</p></li><li class="li-1"><p class="a-2">设计模式</p><ul class="ul-2"><li class="li-3"><p class="a-4">创建型模式</p><ul class="ul-4"><li class="li-5"><a href="pattern-factory.html" class="a-6">工厂模式</a></li><li class="li-5"><a href="pattern-abstract-factory.html" class="a-6">抽象工厂模式</a></li><li class="li-5"><a href="pattern-singleton.html" class="a-6">单例模式</a></li><li class="li-5"><p class="a-6">[建造者模式]</p></li><li class="li-5"><p class="a-6">[原型模式]</p></li></ul></li><li class="li-3"><p class="a-4">结构型模式</p><ul class="ul-4"><li class="li-5"><p class="a-6">[适配器模式]</p></li><li class="li-5"><p class="a-6">[桥接模式]</p></li><li class="li-5"><a href="pattern-decotators.html" class="a-6">装饰模式</a></li><li class="li-5"><p class="a-6">[组合模式]</p></li><li class="li-5"><p class="a-6">[外观模式]</p></li><li class="li-5"><p class="a-6">[享元模式]</p></li><li class="li-5"><a href="pattern-proxy.html" class="a-6">代理模式</a></li></ul></li><li class="li-3"><p class="a-4">行为型模式</p><ul class="ul-4"><li class="li-5"><p class="a-6">[模板方法模式]</p></li><li class="li-5"><p class="a-6">[命令模式]</p></li><li class="li-5"><p class="a-6">[迭代器模式]</p></li><li class="li-5"><a href="pattern-publishsubscribe.html" class="a-6">观察者模式</a></li><li class="li-5"><p class="a-6">[中介者模式]</p></li><li class="li-5"><p class="a-6">[备忘录模式]</p></li><li class="li-5"><p class="a-6">[解释器模式]</p></li><li class="li-5"><a href="pattern-state.html" class="a-6">状态模式</a></li><li class="li-5"><a href="pattern-strategy.html" class="a-6">策略模式</a></li><li class="li-5"><p class="a-6">[职责链模式]</p></li><li class="li-5"><p class="a-6">[访问者模式]</p></li></ul></li></ul></li><li class="li-1"><p class="a-2">webpack</p><ul class="ul-2"><li class="li-3"><a href="webpack-index.html" class="a-4">webpack</a></li></ul></li></ul>
    </aside>
        <main class="page"><div class="page-bd">
        <h1>策略模式？</h1>
<blockquote>
<p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
</blockquote>
<blockquote>
<p>核心：将算法的使用和算法的实现分离开来。<br>
一个基于策略模式的程序至少由两部分组成：<br>
第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。<br>
第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context 中要维持对某个策略对象的引用</p>
</blockquote>
<p>优点：</p>
<ul>
<li>策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。</li>
<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展。</li>
<li>策略模式中的代码可以复用。</li>
</ul>
<h3>实现</h3>
<blockquote>
<p>策略模式可以用于组合一系列算法，也可用于组合一系列业务规则</p>
</blockquote>
<details><summary>面向对象实现</summary>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> performanceA = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
performanceA.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
    <span class="hljs-keyword">return</span> salary * <span class="hljs-number">4</span>;
};      
<span class="hljs-keyword">var</span> performanceB = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
performanceB.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
    <span class="hljs-keyword">return</span> salary * <span class="hljs-number">3</span>;
};
<span class="hljs-keyword">var</span> performanceC = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
performanceC.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
    <span class="hljs-keyword">return</span> salary * <span class="hljs-number">2</span>;
};
<span class="hljs-comment">// 奖金类</span>
<span class="hljs-keyword">var</span> Bouns = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.salary = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 原始工资</span>
    <span class="hljs-keyword">this</span>.levelObj = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 绩效等级对应的策略对象</span>
};
Bouns.prototype.setSalary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
    <span class="hljs-keyword">this</span>.salary = salary;  <span class="hljs-comment">// 保存员工的原始工资</span>
};
Bouns.prototype.setlevelObj = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">levelObj</span>)</span>{
    <span class="hljs-keyword">this</span>.levelObj = levelObj;  <span class="hljs-comment">// 设置员工绩效等级对应的策略对象</span>
};
<span class="hljs-comment">// 取得奖金数</span>
Bouns.prototype.getBouns = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 把计算奖金的操作委托给对应的策略对象</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.levelObj.calculate(<span class="hljs-keyword">this</span>.salary);
};
<span class="hljs-keyword">var</span> bouns = <span class="hljs-keyword">new</span> Bouns();
bouns.setSalary(<span class="hljs-number">10000</span>);
bouns.setlevelObj(<span class="hljs-keyword">new</span> performanceA()); <span class="hljs-comment">// 设置策略对象</span>
<span class="hljs-built_in">console</span>.log(bouns.getBouns());  <span class="hljs-comment">// 40000</span>

bouns.setSalary(<span class="hljs-number">15000</span>);
bouns.setlevelObj(<span class="hljs-keyword">new</span> performanceB()); <span class="hljs-comment">// 设置策略对象</span>
<span class="hljs-built_in">console</span>.log(bouns.getBouns());  <span class="hljs-comment">// 45000</span>
</code></pre>
</details>
<details><summary>javascript实现</summary>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> obj = {
        <span class="hljs-string">"A"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
            <span class="hljs-keyword">return</span> salary * <span class="hljs-number">4</span>;
        },
        <span class="hljs-string">"B"</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
            <span class="hljs-keyword">return</span> salary * <span class="hljs-number">3</span>;
        },
        <span class="hljs-string">"C"</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>) </span>{
            <span class="hljs-keyword">return</span> salary * <span class="hljs-number">2</span>;
        } 
};
<span class="hljs-keyword">var</span> calculateBouns =<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">level,salary</span>) </span>{
    <span class="hljs-keyword">return</span> obj[level](salary);
};
<span class="hljs-built_in">console</span>.log(calculateBouns(<span class="hljs-string">'A'</span>,<span class="hljs-number">10000</span>)); <span class="hljs-comment">// 40000</span>
</code></pre>
</details>
<blockquote>
<p>策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则</p>
</blockquote>
<details><summary>表单校验</summary>
<pre><code class="language-javascript"><span class="hljs-comment">// 策略对象</span>
<span class="hljs-keyword">var</span> strategys = {
    <span class="hljs-attr">isNotEmpty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,errorMsg</span>) </span>{
        <span class="hljs-keyword">if</span>(value === <span class="hljs-string">''</span>) {
            <span class="hljs-keyword">return</span> errorMsg;
        }
    },
    <span class="hljs-comment">// 限制最小长度</span>
    minLength: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,length,errorMsg</span>) </span>{
        <span class="hljs-keyword">if</span>(value.length &lt; length) {
            <span class="hljs-keyword">return</span> errorMsg;
        }
    },
    <span class="hljs-comment">// 手机号码格式</span>
    mobileFormat: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,errorMsg</span>) </span>{
        <span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/(^1[3|5|8][0-9]{9}$)/</span>.test(value)) {
            <span class="hljs-keyword">return</span> errorMsg;
        }
    } 
};
<span class="hljs-keyword">var</span> Validator = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.cache = [];  <span class="hljs-comment">// 保存效验规则</span>
};
Validator.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dom,rules</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, rule; rule = rules[i++]; ){
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rule</span>)</span>{
            <span class="hljs-keyword">var</span> strategyAry = rule.strategy.split(<span class="hljs-string">":"</span>);
            <span class="hljs-keyword">var</span> errorMsg = rule.errorMsg;
            self.cache.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                <span class="hljs-keyword">var</span> strategy = strategyAry.shift();
                strategyAry.unshift(dom.value);
                strategyAry.push(errorMsg);
                <span class="hljs-keyword">return</span> strategys[strategy].apply(dom,strategyAry);
            });
        })(rule);
    }
};
Validator.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, validatorFunc; validatorFunc = <span class="hljs-keyword">this</span>.cache[i++]; ) {
    <span class="hljs-keyword">var</span> msg = validatorFunc(); <span class="hljs-comment">// 开始效验 并取得效验后的返回信息</span>
    <span class="hljs-keyword">if</span>(msg) {
        <span class="hljs-keyword">return</span> msg;
    }
    }
};
<span class="hljs-comment">// 代码调用</span>
<span class="hljs-keyword">var</span> registerForm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"registerForm"</span>);
<span class="hljs-keyword">var</span> validateFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> validator = <span class="hljs-keyword">new</span> Validator(); <span class="hljs-comment">// 创建一个Validator对象</span>
    <span class="hljs-comment">/* 添加一些效验规则 */</span>
    validator.add(registerForm.userName,[
        {<span class="hljs-attr">strategy</span>: <span class="hljs-string">'isNotEmpty'</span>,<span class="hljs-attr">errorMsg</span>:<span class="hljs-string">'用户名不能为空'</span>},
        {<span class="hljs-attr">strategy</span>: <span class="hljs-string">'minLength:6'</span>,<span class="hljs-attr">errorMsg</span>:<span class="hljs-string">'用户名长度不能小于6位'</span>}
    ]);
    validator.add(registerForm.password,[
        {<span class="hljs-attr">strategy</span>: <span class="hljs-string">'minLength:6'</span>,<span class="hljs-attr">errorMsg</span>:<span class="hljs-string">'密码长度不能小于6位'</span>},
    ]);
    validator.add(registerForm.phoneNumber,[
        {<span class="hljs-attr">strategy</span>: <span class="hljs-string">'mobileFormat'</span>,<span class="hljs-attr">errorMsg</span>:<span class="hljs-string">'手机号格式不正确'</span>},
    ]);
    <span class="hljs-keyword">var</span> errorMsg = validator.start(); <span class="hljs-comment">// 获得效验结果</span>
    <span class="hljs-keyword">return</span> errorMsg; <span class="hljs-comment">// 返回效验结果</span>
};
</code></pre>
</details>
<div class="page-nav"><a class="pre" href="pattern-state.html">←状态模式</a><a class="next" href="webpack-index.html">webpack→</a></div>
        </div>
    </main>
        </div>
        <script>
        const pageName = location.href.replace(/^(.*)\/([^/]*).html$/i, "$2");
            const menu = document.querySelector('.sidebar ul');
            const current = menu.querySelector('a[href="' + pageName + '.html"]');
            const list = document.querySelectorAll('.sidebar li');
            const cache = {};
            list.forEach((item, index) => {
                const ul = item.querySelector('ul');
                if (ul) {
                    const holder = item.firstElementChild;
                    holder.setAttribute('data-holder', index);
                    holder.setAttribute('class', 'holder');
                    ul.setAttribute('data-menu', index);
                    cache[index] = ul;
                }
            })
            if (current) {
                current.setAttribute('class', 'cur');
                displayParent(current);
            }
            menu.addEventListener('click', (e) => {
                const target = e.target;
                const holder = target.getAttribute('data-holder');
                if (holder) {
                    const block = cache[holder].style.display === 'block';
                    cache[holder].style.display = block ? 'none' : 'block';
                    target.setAttribute('class', block ? 'holder' : 'holder active');
                }
            });

            function displayParent(ele) {
                const ul = ele.parentElement.parentElement;
                if (ul && ul.getAttribute('data-menu')) {
                    ul.style.display = 'block';
                    ul.previousElementSibling.setAttribute('class', 'holder active');
                    displayParent(ul);
                }
            }
        </script>
        <script src="../assets/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    </body>
    </html>