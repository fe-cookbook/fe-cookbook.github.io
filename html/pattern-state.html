<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>状态模式</title>
        <link rel="stylesheet" href="../assets/style.css">
    </head>
    
    <body>
        <div class="app">
        <header class="navbar"><p><a class="logo" href="/">fe-cookbook</a></p>
<div class="menus">
<a class="item" href="/">首页</a>
</div>
</header>
        <aside class="sidebar">
    <ul class="ul-0"><li class="li-1"><p class="a-2">前端面试</p></li><li class="li-1"><p class="a-2">html/css</p><ul class="ul-2"><li class="li-3"><a href="html-html5.html" class="a-4">html5</a></li></ul></li><li class="li-1"><p class="a-2">javascrpt</p><ul class="ul-2"><li class="li-3"><a href="javascript-render.html" class="a-4">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li><li class="li-3"><a href="javascript-clone.html" class="a-4">深拷贝和浅拷贝？</a></li><li class="li-3"><a href="javascript-isnan.html" class="a-4">怎么判断一个变量是不是 NaN?</a></li><li class="li-3"><a href="javascript-reduce.html" class="a-4">array reduce 返回值是什么？</a></li><li class="li-3"><a href="javascript-vueprototype.html" class="a-4">vue 组件挂载到全局方法？</a></li><li class="li-3"><a href="javascript-constructor.html" class="a-4">构造函数的返回值是什么？</a></li><li class="li-3"><a href="javascript-vueinsertcomponent.html" class="a-4">怎么通过编程的方式而不是<'my-component'>的方式动态的插入 Vue components?</a></li><li class="li-3"><a href="javascript-object_get.html" class="a-4">获取对象路径处的值\_.get(object, a.b.c, default)</a></li><li class="li-3"><a href="javascript-null.html" class="a-4">[typeof null, null instanceof Object]表达式的返回值是什么？</a></li><li class="li-3"><a href="javascript-array_map_parseint.html" class="a-4">["1", "2", "3"].map(parseInt) 返回值是什么？</a></li><li class="li-3"><a href="javascript-debounce.html" class="a-4">什么是防抖和节流？有什么区别？如何实现？</a></li><li class="li-3"><a href="javascript-object_defineproperty.html" class="a-4">Object.defineProperty 了解有多少？什么是属性描述符？</a></li><li class="li-3"><a href="javascript-mutationobserver.html" class="a-4">怎么监视对 DOM 树的变化</a></li><li class="li-3"><a href="javascript-vueerror.html" class="a-4">Vue 是怎么进行错误处理的？</a></li><li class="li-3"><a href="javascript-esmodules.html" class="a-4">ES6 Modules？</a></li><li class="li-3"><a href="javascript-bind.html" class="a-4">实现一个 bind 函数？</a></li></ul></li></ul><ul class="ul-0"><li class="li-1"><p class="a-2">基础知识</p></li><li class="li-1"><p class="a-2">设计模式</p><ul class="ul-2"><li class="li-3"><p class="a-4">创建型模式</p><ul class="ul-4"><li class="li-5"><a href="pattern-factory.html" class="a-6">工厂模式</a></li><li class="li-5"><a href="pattern-abstract-factory.html" class="a-6">抽象工厂模式</a></li><li class="li-5"><a href="pattern-singleton.html" class="a-6">单例模式</a></li><li class="li-5"><p class="a-6">[建造者模式]</p></li><li class="li-5"><p class="a-6">[原型模式]</p></li></ul></li><li class="li-3"><p class="a-4">结构型模式</p><ul class="ul-4"><li class="li-5"><p class="a-6">[适配器模式]</p></li><li class="li-5"><p class="a-6">[桥接模式]</p></li><li class="li-5"><a href="pattern-decotators.html" class="a-6">装饰模式</a></li><li class="li-5"><p class="a-6">[组合模式]</p></li><li class="li-5"><p class="a-6">[外观模式]</p></li><li class="li-5"><p class="a-6">[享元模式]</p></li><li class="li-5"><a href="pattern-proxy.html" class="a-6">代理模式</a></li></ul></li><li class="li-3"><p class="a-4">行为型模式</p><ul class="ul-4"><li class="li-5"><p class="a-6">[模板方法模式]</p></li><li class="li-5"><p class="a-6">[命令模式]</p></li><li class="li-5"><p class="a-6">[迭代器模式]</p></li><li class="li-5"><a href="pattern-publishsubscribe.html" class="a-6">观察者模式</a></li><li class="li-5"><p class="a-6">[中介者模式]</p></li><li class="li-5"><p class="a-6">[备忘录模式]</p></li><li class="li-5"><p class="a-6">[解释器模式]</p></li><li class="li-5"><a href="pattern-state.html" class="a-6">状态模式</a></li><li class="li-5"><a href="pattern-strategy.html" class="a-6">策略模式</a></li><li class="li-5"><p class="a-6">[职责链模式]</p></li><li class="li-5"><p class="a-6">[访问者模式]</p></li></ul></li></ul></li><li class="li-1"><p class="a-2">webpack</p><ul class="ul-2"><li class="li-3"><a href="webpack-index.html" class="a-4">webpack</a></li></ul></li></ul>
    </aside>
        <main class="page"><div class="page-bd">
        <h1>状态模式</h1>
<blockquote>
<p>优点：避免大量的 If/else 导致代码臃肿，更灵活、便于维护与扩展。<br>
缺点：类个数增加，使用不当程序结构会比较混乱。</p>
</blockquote>
<p>主要有以下角色：</p>
<p>Context(环境类)：环境类种维护了一个 State 对象，它定义了当前状态。<br>
State(抽象状态类)：定义具体状态类需要实现的方法。<br>
ConcreteState(具体状态类)：封装了一个状态对应的行为。</p>
<pre><code class="language-javascript"><span class="hljs-comment">/**
 * 创建State抽象状态类：
 * @class State
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>{
  audit() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"audit"</span>);
  }
  notpass() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"notpass"</span>);
  }
  pass() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"pass"</span>);
  }
}

<span class="hljs-comment">/**
 * 创建ConcreteState具体状态类，并实现State 接口：
 * @class Teamleader
 * @extends {State}
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teamleader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{
  audit() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"audit"</span>);
  }
  notpass() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"notpass"</span>);
  }
  pass() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"pass"</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{
  audit() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"audit"</span>);
  }
  notpass() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"notpass"</span>);
  }
  pass() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"pass"</span>);
  }
}

<span class="hljs-comment">/**
 * 创建Context环境类
 * @class Context
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>{
  setState(State) {
    <span class="hljs-keyword">this</span>.stete = State;
  }
  audit() {
    <span class="hljs-keyword">this</span>.stete.audit();
  }
  notpass() {
    <span class="hljs-keyword">this</span>.stete.notpass();
  }
  pass() {
    <span class="hljs-keyword">this</span>.stete.pass();
  }
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> Context();
c.setState(<span class="hljs-keyword">new</span> Teamleader());
c.audit();
c.pass();
c.setState(<span class="hljs-keyword">new</span> Manager());
c.audit();
c.pass();
</code></pre>
<p>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为，避免了使用 if-else 或者 switch-case 语句，同时代码结构清晰能够保证扩展性和维护性。但是状态模式违法开闭原则，而且在 context 类中耦合状态对象，当状态多的情况下，却会导致代码混乱而且不易维护。</p>
<div class="page-nav"><a class="pre" href="pattern-publishsubscribe.html">←观察者模式</a><a class="next" href="pattern-strategy.html">策略模式→</a></div>
        </div>
    </main>
        </div>
        <script>
        const pageName = location.href.replace(/^(.*)\/([^/]*).html$/i, "$2");
            const menu = document.querySelector('.sidebar ul');
            const current = menu.querySelector('a[href="' + pageName + '.html"]');
            const list = document.querySelectorAll('.sidebar li');
            const cache = {};
            list.forEach((item, index) => {
                const ul = item.querySelector('ul');
                if (ul) {
                    const holder = item.firstElementChild;
                    holder.setAttribute('data-holder', index);
                    holder.setAttribute('class', 'holder');
                    ul.setAttribute('data-menu', index);
                    cache[index] = ul;
                }
            })
            if (current) {
                current.setAttribute('class', 'cur');
                displayParent(current);
            }
            menu.addEventListener('click', (e) => {
                const target = e.target;
                const holder = target.getAttribute('data-holder');
                if (holder) {
                    const block = cache[holder].style.display === 'block';
                    cache[holder].style.display = block ? 'none' : 'block';
                    target.setAttribute('class', block ? 'holder' : 'holder active');
                }
            });

            function displayParent(ele) {
                const ul = ele.parentElement.parentElement;
                if (ul && ul.getAttribute('data-menu')) {
                    ul.style.display = 'block';
                    ul.previousElementSibling.setAttribute('class', 'holder active');
                    displayParent(ul);
                }
            }
        </script>
        <script src="../assets/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    </body>
    </html>