<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>发布订阅模式？</title>
        <link rel="stylesheet" href="../assets/style.css">
    </head>
    
    <body>
        <div class="app">
        <header class="navbar"></header>
        <aside class="sidebar">
    <ul class="ul-0"><li class="li-1"><p class="a-2">JAVASCRIPT</p></li><li class="li-1"><p class="a-2">基础知识</p><ul class="ul-2"><li class="li-3"><a href="object_get.html" class="a-4">获取对象路径处的值_.get(object, a.b.c, default)</a></li><li class="li-3"><a href="null.html" class="a-4">[typeof null, null instanceof Object]表达式的返回值是什么？</a></li><li class="li-3"><a href="array_map_parseint.html" class="a-4">["1", "2", "3"].map(parseInt) 返回值是什么？</a></li><li class="li-3"><a href="debounce.html" class="a-4">什么是防抖和节流？有什么区别？如何实现？</a></li></ul></li><li class="li-1"><p class="a-2">设计模式</p><ul class="ul-2"><li class="li-3"><p class="a-4">创建型模式</p><ul class="ul-4"><li class="li-5"><a href="singleton.html" class="a-6">单例模式</a></li></ul></li><li class="li-3"><p class="a-4">结构型模式</p><ul class="ul-4"><li class="li-5"><a href="proxy.html" class="a-6">代理模式</a></li></ul></li><li class="li-3"><p class="a-4">行为型模式</p><ul class="ul-4"><li class="li-5"><a href="strategy.html" class="a-6">策略模式</a></li><li class="li-5"><a href="publishsubscribe.html" class="a-6">发布-订阅模式</a></li></ul></li></ul></li></ul>
    </aside>
        <main class="page"><div class="page-bd">
        <h1>发布订阅模式？</h1>
<blockquote>
<p>定义：对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知</p>
</blockquote>
<blockquote>
<p>核心：<br>
取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。<br>
与传统的发布-订阅模式实现方式（将订阅者自身当成引用传入发布者）不同，在JS中通常使用注册回调函数的形式来订阅</p>
</blockquote>
<p>优缺点：</p>
<ul>
<li>一为时间上的解耦，二为对象之间的解耦。可以用在异步编程中与MV*框架中</li>
<li>创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销</li>
<li>弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解</li>
</ul>
<h3>实现</h3>
<details><summary>点击查看</summary>
<pre><code class="language-javascript"> <span class="hljs-keyword">const</span> Event = <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> events = {};

    <span class="hljs-comment">// 绑定事件监听</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listen</span>(<span class="hljs-params">key, fn</span>) </span>{
        <span class="hljs-keyword">if</span> (!events[key]) {
            events[key] = [];
        }
        events[key].push(fn);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// 触发对应事件</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trigger</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">Array</span>.prototype.shift.apply(<span class="hljs-built_in">arguments</span>),
            fns = events[key];
        <span class="hljs-keyword">if</span> (!fns || fns.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fn <span class="hljs-keyword">of</span> fns) {
            fn.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// 移除相关事件</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">key, fn</span>) </span>{
        <span class="hljs-keyword">let</span> fns = events[key];
        <span class="hljs-comment">// 如果之前没有绑定事件</span>
        <span class="hljs-comment">// 或者没有指明要移除的事件</span>
        <span class="hljs-comment">// 直接返回</span>
        <span class="hljs-keyword">if</span> (!fns || !fn) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-comment">// 反向遍历移除置指定事件函数</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = fns.length - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) {
            <span class="hljs-keyword">let</span> _fn = fns[l];
            <span class="hljs-keyword">if</span> (_fn === fn) {
                fns.splice(l, <span class="hljs-number">1</span>);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> {
        listen,
        trigger,
        remove
    }
})();

<span class="hljs-comment">// 为对象动态安装 发布-订阅 功能</span>
<span class="hljs-keyword">const</span> installEvent = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> Event) {
        obj[key] = Event[key];
    }
};

<span class="hljs-keyword">const</span> statusObj = {};
installEvent(statusObj);

<span class="hljs-comment">// 绑定自定义事件和回调函数</span>
statusObj.listen(<span class="hljs-string">"event01"</span>, (fn1 = <span class="hljs-function"><span class="hljs-params">status</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Status is"</span>, status, <span class="hljs-string">"at event01"</span>);
    })
);

statusObj.trigger(<span class="hljs-string">"event01"</span>, <span class="hljs-number">1</span>);
statusObj.remove(<span class="hljs-string">"event01"</span>, fn1);

<span class="hljs-comment">// 输出: false</span>
<span class="hljs-comment">// 说明删除成功</span>
<span class="hljs-built_in">console</span>.log(statusObj.trigger(<span class="hljs-string">"event01"</span>, <span class="hljs-number">2</span>));
</code></pre>
</details>
<h3>发布订阅模式 vs 观察者模式</h3>
<h5>观察者</h5>
<div class="mermaid">graph TD
    A(Subject) --> |Fire Event| B(Observer)
    B(Observer) -.-> |Subscribe| A(Subject)
    classDef a fill:#ceffd0;
    classDef b fill:#fefe9a;
    class A a;
    class B b;</div><h5>发布订阅模式</h5>
<div class="mermaid">graph TD
    A(Publisher) --> |Publish Event| B(Event Channel)
    B(Event Channel) --> |Fire Event| C(Observer)
    C(Observer) -.-> |Subscribe| B(Event Channel)
    classDef a fill:#ceffd0;
    classDef b fill:#ffcf99;
    classDef c fill:#fefe9a;
    class A a;
    class B b;
    class C c;</div><ul>
<li>在Observer模式中，Observers知道Subject，同时Subject还保留了Observers的记录。然而，在发布者/订阅者中，发布者和订阅者不需要彼此了解。他们只是在消息队列或代理的帮助下进行通信。</li>
<li>在Publisher / Subscriber模式中，组件是松散耦合的，而不是Observer模式。</li>
<li>观察者模式主要以同步方式实现，即当某些事件发生时，Subject调用其所有观察者的适当方法。发布者/订阅者在大多情况下是异步方式（使用消息队列）。</li>
<li>观察者模式需要在单个应用程序地址空间中实现。另一方面，发布者/订阅者模式更像是跨应用程序模式。</li>
</ul>
<div class="page-nav"><a class="pre" href="strategy.html">←策略模式</a></div>
        </div>
    </main>
        </div>
        <script>
        const pageName = location.href.replace(/^(.*)\/([^/]*).html$/i, "$2");
            const menu = document.querySelector('.sidebar ul');
            const current = menu.querySelector('a[href="' + pageName + '.html"]');
            const list = document.querySelectorAll('.sidebar li');
            const cache = {};
            list.forEach((item, index) => {
                const ul = item.querySelector('ul');
                if (ul) {
                    const holder = item.firstElementChild;
                    holder.setAttribute('data-holder', index);
                    holder.setAttribute('class', 'holder');
                    ul.setAttribute('data-menu', index);
                    cache[index] = ul;
                }
            })
            if (current) {
                current.setAttribute('class', 'cur');
                displayParent(current);
            }
            menu.addEventListener('click', (e) => {
                const target = e.target;
                const holder = target.getAttribute('data-holder');
                if (holder) {
                    const block = cache[holder].style.display === 'block';
                    cache[holder].style.display = block ? 'none' : 'block';
                    target.setAttribute('class', block ? 'holder' : 'holder active');
                }
            });

            function displayParent(ele) {
                const ul = ele.parentElement.parentElement;
                if (ul && ul.getAttribute('data-menu')) {
                    ul.style.display = 'block';
                    ul.previousElementSibling.setAttribute('class', 'holder active');
                    displayParent(ul);
                }
            }
        </script>
        <script src="../assets/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    </body>
    </html>